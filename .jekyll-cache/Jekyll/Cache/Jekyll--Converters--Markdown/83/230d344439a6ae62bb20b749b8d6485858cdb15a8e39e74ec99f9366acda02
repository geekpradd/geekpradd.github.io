I"ß<p>Reverse Engineering is one of the most interesting fields in cybersecurity and ethical hacking. Through this post we will try to simplify this field by going through the ideas involved in a step by step manner. Weâ€™ll be focussing on simple ELF Linux executables for now and later on we will also investigate reverse engineering windows exe executables and bytecode for JVM etc. So letâ€™s get started!</p>

<h2 id="what-is-reverse-engineering">What is Reverse Engineering?</h2>

<p>In simple terms Reverse Engineering refers to the process of deconstructing any engineered object to figure out the internal mechanisms. One example would be cracking games where crackers have to reverse engineer the game code on their PC in order to be able to distribute it for free.</p>

<p>Most software that is not open source does not provide itâ€™s source code and instead we have the compiled executable code with us. We have to in a way figure out what the soruce was (or a subset of it) from the executable code. This in general is not easy to do so because machine/assembly code is far complex and also has a lot of compiler optimisations added to it.</p>

<p>In general the executable provided to us may not be binary or assembly instructions it could also be in the form of platform independent byte code that any virtual machine (say the Java virtual machine) executes. We will however look at only Linux executables generated from C/C++ code in this tutorial as that provides a pretty great overview of the field. To do so however we must understand basic assembly.</p>

<h2 id="introduction-to-x86-assembly">Introduction to x86 Assembly</h2>

<p>x86 Assembly is the assembly instruction code used by the non ARM (Intel/AMD) processors and most CTF problems will use this instruction code. The instructions generated may vary from OS to OS and we will consider linux executables (ELF format).
Also before proceeding note that there a variety of different assembly syntaxes, we will be using Intel Assembly syntax in this tutorial although the alternative AT&amp;T syntax is also quite common.</p>

<p>Assembly language has very few constructs compared to higher level languages, instead having to rely on some primitive operations. Most assembly operations happen with respect to registers, which are special memory locations on the CPU which is way faster than directly accessing RAM and a lot of special values are stored here. We will first go through these registers and their naming conventions:</p>

<h3 id="registers">Registers</h3>

<p>A register can be thought of as a special memory location in the CPU. There are 6 general purpose registers and 2 special registers available. We can do all possible assembly operations on these registers like adding values, subtracting etc.</p>

<p>The 8 registers are named as <code>EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP</code>.</p>

<p>However if you go through any assembly code you will see various variations in the register names. There are different ways in which you can call different registers.
The above naming provides you access to the 32 bits associated with every register. Nowadays in 64 bit systems each register is allocated 64 bits which can be called by using the names <code>RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP</code>.</p>

<p>Similarly if you want only 16 bits you will call them as <code>AX, BX, CX.. </code> and so on. To get eight bits you will use <code>AL, BL, CL..</code> and so on. The following diagram explains this better:</p>

<p><img src="/images/x86-registers.png" alt="registers" /></p>

<p>For more details on registers go through <a href="https://wiki.skullsecurity.org/index.php?title=Registers">this link</a>
The general purpose registers can be used for computation and infact it is only through these registers that you can do operations like addition subtraction. So if you want to say add two numbers stored at two different memory locations you would have to load the values stored there into the registers and then operate and then write these values again into the memory location. We will not be going into specifics of these operations instead we will quickly summarise them below.</p>

<p>One more important thing to note is that <code>ESP and EBP</code> are used to store the memory location of the stack. <code>ESP</code> points to the top of the stack and <code>EBP</code> (generally) refers to the bottom. Declaring variables on the stack would therefore be equivalent to adding and subtracting values from <code>ESP</code> and <code>EBP</code>. Note that you generally donâ€™t need to know the exact specifics but having a vague idea works.</p>

<p>There are also a couple of FLAGS that are used by assembly. Think of a flag as a specific boolean variable which is set by assembly instructions. Some flags are the zero flag, the sign flag etc. We will mostly be needing the zero flag in reverse engineering since this flag is used many times to determine control flow.</p>

<h3 id="basic-assembly-operations">Basic Assembly Operations</h3>

<h4 id="mov-operation"><code>mov</code> operation</h4>
<p>The <code>mov</code> operation is one of the simplest operations and all it does is moves values (or assigns values). The syntax of <code>mov</code> is the following:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">mov destination, source</code></pre></figure>

<p>Suppose I want to set the value <code>12</code> in <code>EAX</code> then I would run the operation:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">mov eax, 12</code></pre></figure>

<p>One more thing to understand is dereferencing. This is similar to C. Suppose the register <code>ECX</code> holds the value <code>0x6665f</code> which is a memory location. <code>ECX</code> is therfore similar to a pointer. If I want to load the value stored at <code>0x6665f</code> into <code>EAX</code> I will use the following command:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">mov eax, [ecx]</code></pre></figure>

<p>The brackets <code>[]</code> functions similar to <code>*</code> in C/C++ and it dereferences the memory location and outputs the value at that location.</p>

<h4 id="add-operation"><code>add</code> operation</h4>

<p>Consider the following assembly code:</p>

:ET